// __tests__/EldSimulator.test.ts

import { eldSimulator, SimulationScenario, EldDeviceType } from '../services/EldSimulator';\nimport { eldTestConfig, TestMode } from '../services/EldTestConfig';\nimport { BLEDevice, NotifyData, ConnectionFailure } from '../src/utils/TTMBLEManager';\n\n// Mock Platform for testing\njest.mock('react-native', () => ({\n  Platform: {\n    OS: 'web'\n  },\n  NativeModules: {},\n  NativeEventEmitter: jest.fn().mockImplementation(() => ({\n    addListener: jest.fn(),\n    removeAllListeners: jest.fn()\n  }))\n}));\n\ndescribe('ELD Simulator', () => {\n  beforeEach(() => {\n    eldSimulator.reset();\n    jest.clearAllMocks();\n  });\n\n  describe('Basic Functionality', () => {\n    test('should initialize successfully', async () => {\n      await expect(eldSimulator.initSDK()).resolves.toBeUndefined();\n    });\n\n    test('should have predefined devices available', () => {\n      const devices = eldSimulator.getAvailableDevices();\n      expect(devices).toHaveLength(5);\n      expect(devices[0]).toHaveProperty('name');\n      expect(devices[0]).toHaveProperty('address');\n      expect(devices[0]).toHaveProperty('deviceType');\n    });\n\n    test('should not be scanning initially', () => {\n      expect(eldSimulator.isCurrentlyScanning()).toBe(false);\n    });\n\n    test('should have no connected device initially', () => {\n      expect(eldSimulator.getConnectedDevice()).toBeNull();\n    });\n  });\n\n  describe('Device Scanning', () => {\n    test('should start scanning and discover devices', async () => {\n      const discoveredDevices: BLEDevice[] = [];\n      \n      eldSimulator.onDeviceScanned((device: BLEDevice) => {\n        discoveredDevices.push(device);\n      });\n\n      await eldSimulator.startScan(3000);\n      \n      // Wait for scan to complete\n      await new Promise(resolve => setTimeout(resolve, 4000));\n      \n      expect(discoveredDevices.length).toBeGreaterThan(0);\n      expect(discoveredDevices[0]).toHaveProperty('id');\n      expect(discoveredDevices[0]).toHaveProperty('name');\n      expect(discoveredDevices[0]).toHaveProperty('address');\n      expect(discoveredDevices[0]).toHaveProperty('signal');\n    });\n\n    test('should emit scan events', async () => {\n      const scanStopCallback = jest.fn();\n      const scanFinishCallback = jest.fn();\n      \n      eldSimulator.on('ON_SCAN_STOP', scanStopCallback);\n      eldSimulator.on('ON_SCAN_FINISH', scanFinishCallback);\n\n      await eldSimulator.startScan(1000);\n      \n      // Wait for scan to auto-stop\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      expect(scanStopCallback).toHaveBeenCalled();\n      expect(scanFinishCallback).toHaveBeenCalled();\n    });\n\n    test('should be able to stop scanning manually', async () => {\n      await eldSimulator.startScan(10000);\n      expect(eldSimulator.isCurrentlyScanning()).toBe(true);\n      \n      await eldSimulator.stopScan();\n      expect(eldSimulator.isCurrentlyScanning()).toBe(false);\n    });\n\n    test('should throw error if starting scan while already scanning', async () => {\n      await eldSimulator.startScan(5000);\n      \n      await expect(eldSimulator.startScan(1000))\n        .rejects.toThrow('Scan already in progress');\n      \n      await eldSimulator.stopScan();\n    });\n  });\n\n  describe('Device Connection', () => {\n    test('should connect to valid device successfully', async () => {\n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices.find(d => d.deviceType === EldDeviceType.TTM_PREMIUM)!;\n      \n      const connectedCallback = jest.fn();\n      const authCallback = jest.fn();\n      \n      eldSimulator.onConnected(connectedCallback);\n      eldSimulator.onAuthenticationPassed(authCallback);\n\n      await eldSimulator.connect(testDevice.address, testDevice.imei);\n      \n      // Wait for connection events\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      expect(connectedCallback).toHaveBeenCalled();\n      expect(authCallback).toHaveBeenCalled();\n      expect(eldSimulator.getConnectedDevice()).toBeTruthy();\n      expect(eldSimulator.getConnectedDevice()?.id).toBe(testDevice.id);\n    });\n\n    test('should fail connection with invalid MAC address', async () => {\n      const connectFailureCallback = jest.fn();\n      eldSimulator.onConnectFailure(connectFailureCallback);\n\n      await expect(eldSimulator.connect('invalid:mac:address', 'someimei'))\n        .rejects.toThrow('Device not found');\n      \n      // Wait for failure event\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      expect(connectFailureCallback).toHaveBeenCalledWith({\n        status: 404,\n        message: 'Device not found'\n      });\n    });\n\n    test('should fail connection with invalid IMEI', async () => {\n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices[0];\n      \n      const connectFailureCallback = jest.fn();\n      eldSimulator.onConnectFailure(connectFailureCallback);\n\n      await expect(eldSimulator.connect(testDevice.address, 'wrongimei'))\n        .rejects.toThrow('IMEI mismatch');\n      \n      // Wait for failure event\n      await new Promise(resolve => setTimeout(resolve, 1200));\n      \n      expect(connectFailureCallback).toHaveBeenCalledWith({\n        status: 401,\n        message: 'IMEI mismatch - authentication failed'\n      });\n    });\n\n    test('should disconnect from connected device', async () => {\n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices.find(d => d.deviceType === EldDeviceType.TTM_STANDARD)!;\n      \n      await eldSimulator.connect(testDevice.address, testDevice.imei);\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      expect(eldSimulator.getConnectedDevice()).toBeTruthy();\n      \n      const disconnectedCallback = jest.fn();\n      eldSimulator.onDisconnected(disconnectedCallback);\n      \n      await eldSimulator.disconnect();\n      \n      expect(disconnectedCallback).toHaveBeenCalled();\n      expect(eldSimulator.getConnectedDevice()).toBeNull();\n    });\n  });\n\n  describe('ELD Data Streaming', () => {\n    test('should start ELD data reporting after connection', async () => {\n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices.find(d => d.deviceType === EldDeviceType.TTM_PREMIUM)!;\n      \n      await eldSimulator.connect(testDevice.address, testDevice.imei);\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      const dataReceivedCallback = jest.fn();\n      eldSimulator.onNotifyReceived(dataReceivedCallback);\n      \n      await eldSimulator.startReportEldData();\n      \n      // Wait for data packets\n      await new Promise(resolve => setTimeout(resolve, 6000));\n      \n      expect(dataReceivedCallback).toHaveBeenCalled();\n      \n      const callArgs = dataReceivedCallback.mock.calls[0][0] as NotifyData;\n      expect(callArgs).toHaveProperty('dataType', 'ELD_DATA');\n      expect(callArgs).toHaveProperty('rawData');\n      \n      const parsedData = JSON.parse(callArgs.rawData);\n      expect(parsedData).toHaveProperty('vehicleData');\n      expect(parsedData).toHaveProperty('driverStatus');\n      expect(parsedData).toHaveProperty('hoursOfService');\n      expect(parsedData).toHaveProperty('timestamp');\n    });\n\n    test('should throw error when starting data reporting without connection', async () => {\n      await expect(eldSimulator.startReportEldData())\n        .rejects.toThrow('No device connected');\n    });\n\n    test('should acknowledge received ELD data', async () => {\n      await expect(eldSimulator.replyReceivedEldData()).resolves.toBeUndefined();\n    });\n\n    test('should send UTC time', async () => {\n      await expect(eldSimulator.sendUTCTime()).resolves.toBeUndefined();\n    });\n  });\n\n  describe('Simulation Scenarios', () => {\n    test('should simulate connection issues', async () => {\n      eldSimulator.setSimulationScenario(SimulationScenario.CONNECTION_ISSUES);\n      \n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices[0];\n      \n      const connectFailureCallback = jest.fn();\n      eldSimulator.onConnectFailure(connectFailureCallback);\n      \n      // Multiple attempts should have higher failure rate\n      let failureCount = 0;\n      for (let i = 0; i < 5; i++) {\n        try {\n          await eldSimulator.connect(testDevice.address, testDevice.imei);\n          await eldSimulator.disconnect();\n        } catch (error) {\n          failureCount++;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      expect(failureCount).toBeGreaterThan(0);\n    });\n\n    test('should simulate authentication failure', async () => {\n      eldSimulator.setSimulationScenario(SimulationScenario.AUTHENTICATION_FAILURE);\n      \n      const devices = eldSimulator.getAvailableDevices();\n      const passwordDevice = devices.find(d => d.isPasswordProtected)!;\n      \n      const connectFailureCallback = jest.fn();\n      eldSimulator.onConnectFailure(connectFailureCallback);\n      \n      await eldSimulator.connect(passwordDevice.address, passwordDevice.imei);\n      \n      // Wait for authentication failure\n      await new Promise(resolve => setTimeout(resolve, 3000));\n      \n      expect(connectFailureCallback).toHaveBeenCalledWith({\n        status: 401,\n        message: 'Password authentication failed'\n      });\n    });\n\n    test('should simulate device malfunction', async () => {\n      eldSimulator.setSimulationScenario(SimulationScenario.DEVICE_MALFUNCTION);\n      \n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices.find(d => d.deviceType === EldDeviceType.TTM_PREMIUM)!;\n      \n      await eldSimulator.connect(testDevice.address, testDevice.imei);\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      const dataReceivedCallback = jest.fn();\n      eldSimulator.onNotifyReceived(dataReceivedCallback);\n      \n      await eldSimulator.startReportEldData();\n      await new Promise(resolve => setTimeout(resolve, 6000));\n      \n      expect(dataReceivedCallback).toHaveBeenCalled();\n      \n      const callArgs = dataReceivedCallback.mock.calls[0][0] as NotifyData;\n      const parsedData = JSON.parse(callArgs.rawData);\n      expect(parsedData.malfunction).toBe(true);\n    });\n\n    test('should simulate data corruption', async () => {\n      eldSimulator.setSimulationScenario(SimulationScenario.DATA_CORRUPTION);\n      \n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices.find(d => d.deviceType === EldDeviceType.TTM_PREMIUM)!;\n      \n      await eldSimulator.connect(testDevice.address, testDevice.imei);\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      const dataReceivedCallback = jest.fn();\n      eldSimulator.onNotifyReceived(dataReceivedCallback);\n      \n      await eldSimulator.startReportEldData();\n      await new Promise(resolve => setTimeout(resolve, 6000));\n      \n      expect(dataReceivedCallback).toHaveBeenCalled();\n      \n      const callArgs = dataReceivedCallback.mock.calls[0][0] as NotifyData;\n      const parsedData = JSON.parse(callArgs.rawData);\n      expect(parsedData.dataIntegrity).toBe(false);\n    });\n  });\n\n  describe('Device Types', () => {\n    test('should handle TTM Premium devices faster', async () => {\n      const premiumDevice = eldSimulator.getAvailableDevices()\n        .find(d => d.deviceType === EldDeviceType.TTM_PREMIUM)!;\n      \n      const startTime = Date.now();\n      await eldSimulator.connect(premiumDevice.address, premiumDevice.imei);\n      const connectionTime = Date.now() - startTime;\n      \n      expect(connectionTime).toBeLessThan(3000); // Should connect relatively quickly\n    });\n\n    test('should handle faulty devices with failures', async () => {\n      const faultyDevice = eldSimulator.getAvailableDevices()\n        .find(d => d.deviceType === EldDeviceType.FAULTY_DEVICE)!;\n      \n      const connectFailureCallback = jest.fn();\n      eldSimulator.onConnectFailure(connectFailureCallback);\n      \n      // Faulty devices should fail frequently\n      let failures = 0;\n      for (let i = 0; i < 3; i++) {\n        try {\n          await eldSimulator.connect(faultyDevice.address, faultyDevice.imei);\n          await eldSimulator.disconnect();\n        } catch (error) {\n          failures++;\n        }\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      \n      expect(failures).toBeGreaterThan(0);\n    });\n\n    test('should handle slow devices with longer delays', async () => {\n      const slowDevice = eldSimulator.getAvailableDevices()\n        .find(d => d.deviceType === EldDeviceType.SLOW_DEVICE)!;\n      \n      const startTime = Date.now();\n      await eldSimulator.connect(slowDevice.address, slowDevice.imei);\n      const connectionTime = Date.now() - startTime;\n      \n      expect(connectionTime).toBeGreaterThan(5000); // Should take longer\n    });\n  });\n\n  describe('Utility Methods', () => {\n    test('should update device battery level', () => {\n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices[0];\n      const originalBattery = testDevice.batteryLevel;\n      \n      eldSimulator.updateDeviceBattery(testDevice.id, 25);\n      \n      const updatedDevice = eldSimulator.getAvailableDevices()\n        .find(d => d.id === testDevice.id)!;\n      expect(updatedDevice.batteryLevel).toBe(25);\n      expect(updatedDevice.batteryLevel).not.toBe(originalBattery);\n    });\n\n    test('should trigger device malfunction', async () => {\n      const devices = eldSimulator.getAvailableDevices();\n      const testDevice = devices.find(d => d.deviceType === EldDeviceType.TTM_PREMIUM)!;\n      \n      await eldSimulator.connect(testDevice.address, testDevice.imei);\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      const malfunctionCallback = jest.fn();\n      eldSimulator.onNotifyReceived(malfunctionCallback);\n      \n      eldSimulator.triggerDeviceMalfunction(testDevice.id);\n      \n      expect(malfunctionCallback).toHaveBeenCalled();\n      \n      const callArgs = malfunctionCallback.mock.calls[0][0] as NotifyData;\n      expect(callArgs.dataType).toBe('MALFUNCTION');\n      \n      const parsedData = JSON.parse(callArgs.rawData);\n      expect(parsedData.errorCode).toBe('DEVICE_MALFUNCTION');\n    });\n\n    test('should reset simulator state', () => {\n      eldSimulator.setSimulationScenario(SimulationScenario.CONNECTION_ISSUES);\n      \n      const devices = eldSimulator.getAvailableDevices();\n      devices[0].isConnected = true;\n      \n      eldSimulator.reset();\n      \n      expect(eldSimulator.getConnectedDevice()).toBeNull();\n      expect(eldSimulator.isCurrentlyScanning()).toBe(false);\n      \n      const resetDevices = eldSimulator.getAvailableDevices();\n      resetDevices.forEach(device => {\n        expect(device.isConnected).toBe(false);\n        expect(device.connectionAttempts).toBe(0);\n      });\n    });\n  });\n});\n\ndescribe('ELD Test Configuration', () => {\n  beforeEach(() => {\n    eldTestConfig.reset();\n  });\n\n  test('should initialize with correct default mode', () => {\n    const config = eldTestConfig.getConfiguration();\n    expect(config.mode).toBe(TestMode.SIMULATOR); // On web platform\n  });\n\n  test('should switch to simulator mode', () => {\n    eldTestConfig.setTestMode(TestMode.SIMULATOR);\n    expect(eldTestConfig.shouldUseSimulator()).toBe(true);\n  });\n\n  test('should return simulator as BLE manager when in simulator mode', () => {\n    eldTestConfig.setTestMode(TestMode.SIMULATOR);\n    const manager = eldTestConfig.getBLEManager();\n    expect(manager).toBe(eldSimulator);\n  });\n\n  test('should run test scenarios', async () => {\n    eldTestConfig.setTestMode(TestMode.SIMULATOR);\n    \n    const originalScenario = eldTestConfig.getConfiguration().scenario;\n    \n    await eldTestConfig.runTestScenario(SimulationScenario.CONNECTION_ISSUES, 1000);\n    \n    // Should restore original scenario after test\n    const finalScenario = eldTestConfig.getConfiguration().scenario;\n    expect(finalScenario).toBe(originalScenario);\n  });\n\n  test('should run connectivity test', async () => {\n    eldTestConfig.setTestMode(TestMode.SIMULATOR);\n    await eldTestConfig.initialize();\n    \n    const result = await eldTestConfig.runConnectivityTest();\n    \n    expect(result).toHaveProperty('success');\n    expect(result).toHaveProperty('details');\n    expect(typeof result.success).toBe('boolean');\n    expect(typeof result.details).toBe('string');\n  });\n\n  test('should get simulator status', () => {\n    eldTestConfig.setTestMode(TestMode.SIMULATOR);\n    \n    const status = eldTestConfig.getSimulatorStatus();\n    \n    expect(status).toHaveProperty('isScanning');\n    expect(status).toHaveProperty('connectedDevice');\n    expect(status).toHaveProperty('availableDevices');\n    expect(status).toHaveProperty('currentScenario');\n    expect(status).toHaveProperty('testMode');\n    \n    expect(Array.isArray(status?.availableDevices)).toBe(true);\n  });\n\n  test('should enable and disable debug mode', () => {\n    eldTestConfig.enableDebugMode(true);\n    expect(eldTestConfig.getConfiguration().enableDebugLogs).toBe(true);\n    \n    eldTestConfig.enableDebugMode(false);\n    expect(eldTestConfig.getConfiguration().enableDebugLogs).toBe(false);\n  });\n});
